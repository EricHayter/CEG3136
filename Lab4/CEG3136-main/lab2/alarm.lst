C:\Users\ehayt075\Downloads\AlarmAssembler F2019\AlarmAssembler F2019\AlarmAssembler\alarm.lst - generated by MGTEK Assembler ASM12 V1.26 Build 144 for WIN32 (x86) - Thu Oct 03 12:06:04 2024

    1:                                 ;------------------------------------------------------
    2:                                 ; Alarm System Assembler Program
    3:                                 ; File: alarm.asm (Alarm System Module)
    4:                                 ; Author: Gilbert Arbez - Hamzah Alghamdi(modified)
    5:                                 ; Date: Fall 2019
    6:                                 ;------------------------------------------------------
   10:                                 
   11:                                 ; Some definitions
   12:                                 ; Location of the register block
   13:          =00000000              Regblk:       equ    $0000 
   14:                                  INCLUDE sections.inc
    1:                                 ;--------------------------------------
    2:                                 ; File: sections.inc
    3:                                 ; Description: Defines the sections for the project.
    4:                                 ;              Note the use of the symbol SECTIONS_DEFINED
    5:                                 ;              for conditional assembly into modules.
    6:                                 ;----------------------------------------
    7:                                 
    8:                                         IFNDEF SECTIONS_DEFINED  ; Start of conditional assembly
    9:          =00000001              SECTIONS_DEFINED   EQU  1        ; prevents future inclusion of the file
   10:                                 
   11:                                 ; Define addresses of various sections
   12:          =00003000              VARIABLES EQU $3000   ; $3000 - $3FFF
   13:          =00002000              PROGRAM   EQU $2000  ; $2000 - $2FFF
   14:          =00002000              STACK     EQU $2000  ; $1000 - $1FFF
   15:                                 
   16:                                 ;----------------------------------------
   17:                                 ; Global Variable section
   18:                                 ; Use the DS - define storage directive
   19:                                 ;              to define space for 
   20:                                 ;              global variables and data
   21:                                 ;              structures.
   22:                                 ;----------------------------------------
   23:                                 globalVar SECTION
   24:          =00003000                      ORG VARIABLES   ; places section in RAM
   25:                                 ;-----------------------------------------
   26:                                 ; Code section
   27:                                 ; Enter assembly instructions (HCS12) to create
   28:                                 ; executable code.
   29:                                 ;-----------------------------------------
   30:                                 code_section SECTION
   31:          =00002000                      ORG PROGRAM  ; places section in RAM - simulates ROM
   32:                                 
   33:                                 ;------------------------------------------
   34:                                 ; Global constants
   35:                                 ; In simple programs (single module) global constants are 
   36:                                 ; simply placed at the end of code and not section is
   37:                                 ; explicitly defined.
   38:                                 ;--------------------------------------------
   39:                                 globalConst SECTION
   40:          =0000245F                      ORG ENDCODE ;--ENDCODE is defined on the second pass of the assembler
   41:                                 
   42:                                 ;----------------------------------------------
   43:                                 ; Defining the start of the globalConst Section
   44:                                 ; The following should be added to the end of the 
   45:                                 ; main module
   46:                                 ;----------------------------------------------
   47:                                 ;       SWITCH code_section 
   48:                                 ;ENDCODE        
   49:                                 
   50:                                          ENDIF  ; End of conditional assembly
   15:                                  INCLUDE alarm.inc
    1:                                 ;---------------------------------
    2:                                 ; File: alarmSimul.inc
    3:                                 ; Description: Include file for Alarm System Simulation
    4:                                 ;              project
    5:                                 ;----------------------------------------------
    6:                                         IFNDEF ALARM_SIMUL_HDR  ; Start of conditional assembly
    7:          =00000001              ALARM_SIMUL_HDR   EQU   1        ; prevents future inclusion of the file
    8:                                 
    9:                                 ; for calculating wins
   10:          =000000FF              NOCHAR        equ    0xff
   11:          =00000007              BEL           equ    0x07
   12:          =00000001              TRUE          equ    1
   13:          =00000000              FALSE         equ    0
   14:          =00000005              NUMCODES      equ    5
   15:          =00000008              XWINSUM        equ   ('X'+'X'+'X')&$FF  ; sum of three X's
   16:          =000000ED              OWINSUM        equ   'O'+'O'+'O'        ; sum of three O's
   17:          =0000000A              NL             equ   $0a                ; NEWLINE
   18:          =0000000D              CR             equ   $0d                ; carriage return
   19:          =00000030              ASCII_CONV_NUM equ   $30                ; For converting digit to ASCII
   20:                                 
   21:                                          ENDIF  ; End of conditional assembly
   16:                                 
   17:                                 ; Dbug12 subroutines
   18:          =0000EE86              putchar        equ   $EE86
   19:          =0000EE84              getchar        equ   $EE84
   20:          =0000EE88              printf         equ   $EE88
   21:          =0000EEA6              writeEEByte    equ   $EEA6
   22:                                 
   23:                                         switch code_section
   24:                                 ;------------------------------------------------------
   25:                                 ; Alarm System Module
   26:                                 
   27:                                 ; Main routine
   28:                                 ; Variables: select - in register B (set by getchar)
   29:                                 ; Description: The main routine for running the game.
   30:                                 ;              Initialises things (via initgb) and the
   31:                                 ;              loops forever playing games.
   32:                                 ;------------------------------------------------------
   33:     2000 CF 2000                        lds #STACK       ; Not reflected in C
   34:     2003 07 27                          bsr inithw       ; initiliase the hardware
   35:     2005 16 2363                        jsr initKeyPad   ;  initKeyPad();
   36:     2008 16 244F                        jsr initSwitches ;  initSwithes();
   37:                                         ; byte select - in register B
   38:                                                         ;do
   39:     200B                        mainloop:                       ; {
   40:     200B CC 2469                        ldd #MENU          ;   printf(MENU);
   41:     200E 15 FB CE76                     jsr [printf,PCr] 
   42:     2012 16 2393                        jsr readKey        ;   select = readKey();
   43:     2015 37                             pshb ; save b
   44:     2016 33                             pulb
   45:     2017 C1 63                          cmpb #'c'          ;   if(select == 'c') configCodes();
   46:     2019 26 05                          bne mnElseif
   47:     201B 16 2062                        jsr configCodes
   48:     201E 20 09                          bra mnEndif
   49:     2020 C1 61                  mnElseif cmpb #'a'         ;   else if(select == 'a') enableAlarm();
   50:     2022 26 05                          bne mnElse
   51:     2024 16 21BC                        jsr enableAlarm
   52:     2027 20 00                          bra mnEndif
   53:     2029                        mnElse                     ;   else /*do nothing*/;
   54:     2029                        mnEndif:
   55:     2029 20 E0                          bra mainloop       ; } while(1);  // loop forever
   56:     202B 3F                             swi                ; never reach here - infinite loop
   57:                                 
   58:                                 ;------------------------------------------------------
   59:                                 ; Subroutine: inithw
   60:                                 ; No parameters
   61:                                 ; Variables: ptx - index register X
   62:                                 ;            pty - index register Y
   63:                                 ; Description: First setup up the microcontroller setting up the clock, 
   64:                                 ;             shutting down the COP watchdog timer, and initialising 
   65:                                 ;             the SCI serial interface. Initialises global variables also.
   66:                                 ;------------------------------------------------------
   67:     202C                        inithw:
   68:                                 ; -- Initialise the hardware
   69:                                 ; Initialise the Phase-Lock-Loop (se page 34 of Dragon 12 Manual
   70:                                 ;       The crystal freq. on the DRAGON12 Plus board is 8 MHz so the default bus speed is 2 MHz
   71:                                 ;       In order to set the bus speed higher than 4 MHz the PLL must be initialized
   72:                                 ;
   73:                                 ;       The math used to set the PLL frequency is:
   74:                                 ;        
   75:                                 ;       PLLCLK = CrystalFreq * 2 * (initSYNR+1) / (initREFDV+1)
   76:                                 ;       
   77:                                 ;       If CrystalFreq = 8Mhz on DRAGON12 Plus board
   78:                                 ;         initSYNR     = 5    PLL multiplier will be 6
   79:                                 ;         initREFDV    = 0    PLL divisor will be 1
   80:                                 
   81:                                 ;       PLLCLK = 4*2*6/1 = 48MHz
   82:                                 ;       The bus speed = PLLCLK / 2 = 24 MHz
   83:                                 ;
   84:                                 ;      
   85:                                 ;********PLL code for 24MHz bus speed from a 4/8/16 crystal
   86:     202C 1410                           sei
   87:     202E CE 0000                        ldx #Regblk
   88:     2031 0D E0 39 80                    bclr Clksel,x,%10000000  ; clear bit 7, clock derived from oscclk
   89:     2035 0C E0 3A 40                    bset Pllctl,x,%01000000  ; Turn PLL on, bit 6 =1 PLL on, bit 6=0 PLL off
   90:     2039 86 05                          ldaa #$05                ; 5+1=6 multiplier 
   91:     203B 6A E0 34                       staa Synr,x
   92:                                 ;        ldaa #$03                ; divisor=3+1=4, 16 *6 /4 = 24Mhz for 16 MHz crystal
   93:     203E 86 01                          ldaa #$01                ; divisor=1+1=2,  8 *6 /2 = 24Mhz for  8 MHz crystal
   94:                                 ;        ldaa #$00                ; divisor=0+1=1,  4 *6 /1 = 24Mhz for  4 MHz crystal
   95:     2040 6A E0 35                       staa Refdv,x
   96:     2043                        wait_b3:
   97:     2043 0F E0 37 08 FB                 brclr Crgflg,x, %00001000 wait_b3  ; Wait until bit 3 = 1
   98:     2048 0C E0 39 80                    bset Clksel,x, %10000000
   99:                                 
  100:                                         ; Setup Serial port
  101:     204C CC 009C                        ldd #156
  102:     204F 5C C8                          std Sc0bdh   ; Sets up the baud rate
  103:     2051 86 0C                          ldaa #$0c
  104:     2053 5A CB                          staa Sc0cr2  ; Enables serial interface
  105:                                         
  106:                                         ; Setup the data in the RAM
  107:                                         ; For the Configuration Module
  108:     2055 1803 0000 3002                 movw #0,alarmCode
  109:     205B 1803 03E8 3000                 movw #1000,mult
  110:     2061 3D                             rts
  111:                                 
  112:                                    switch globalConst
  113:                                 
  114:                                 ;-------------------------------------------------------------------------
  115:                                 ; Data Structures
  116:                                 ; The following data is stored in EEPROM 
  117:                                 ; Following is data array used by testWin 
  118:                                 ;   int alarmCodes[NUMCODES] = { 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF }; 
  119:                                 ;------------------------------------------------------
  120:     245F 0000 FFFF FFFF         alarmCodes dc.w $0000, $FFFF, $FFFF, $FFFF, $FFFF  ; note this will be updated in ROM
           2465 FFFF FFFF 
  121:                                 
  122:                                 ; Message strings
  123:     2469 43 45 47 33 31 33      MENU     dc.b   "CEG3136 Alarm",NL,CR,"c-Config a-Arm",NL,CR,$00
           246F 36 20 41 6C 61 72 
           2475 6D 0A 0D 63 2D 43 
           247B 6F 6E 66 69 67 20 
           2481 61 2D 41 72 6D 0A 
           2487 0D 00 
  124:     2489 0A 0D 00               NEWLINE  dc.b   NL,CR,$00
  125:                                 
  126:                                  
  127:                                 ;----------
  128:                                 ; Include other modules here
  129:                                 ;-----------
  130:                                  INCLUDE        config.asm
    1:                                 ;------------------------------------------------------
    2:                                 ; Alarm System Assembler Program
    3:                                 ; File: config.asm - the CONFIGURATION Module
    4:                                 ; Author: Gilbert Arbez
    5:                                 ; Date: Fall 2010
    6:                                 ;------------------------------------------------------
    7:                                 
    8:                                         SWITCH code_section ; include in the code
    9:                                 ;-----------------------------------
   10:                                 ; Subroutine - configCodes
   11:                                 ; Parameters: none
   12:                                 ; Returns: nothing
   13:                                 ; Local Variables:   ix,  input, flag - on stack
   14:                                 ; Description: Gets user to select alarm code to update/disable. Calls
   15:                                 ;              setcode to update the alarm code.
   16:                                 ;------------------------------------------------------
   17:                                 ; Stack Usage
   18:                                         OFFSET 0 ; to setup offsets into stack
   19:     0000 +0001                  CFG_IX   DS.B 1   ; ix
   20:     0001 +0001                  CFG_INPUT DS.B 1  ; input
   21:     0002 +0001                  CFG_FLAG DS.B 1   ; flag
   22:     0003                        CFG_VARSIZE:
   23:     0003 +0002                  CFB_PR_D        DS.W 1  ; preserve D 
   24:     0005 +0002                  CFG_RA  DS.W 1  ; return address
   25:                                 
   26:     2062 3B                     configCodes: pshd
   27:                                       ; byte ix;  // index into array
   28:                                       ; byte input; // input from user.
   29:                                       ; byte flag;
   30:     2063 1B 9D                        leas -CFG_VARSIZE,SP
   31:     2065 16 20A9                cfg_if1: jsr enterMstCode ; if(enterMstCode())
   32:     2068 97                           tsta
   33:     2069 27 3A                        beq cfg_endif1
   34:     206B                        cfg_loop:               ;     do {
   35:     206B CC 249A                      ldd #CONFIGMSG    ;          printf(CONFIGMSG);
   36:     206E 15 FB CE16                   jsr [printf,PCr]
   37:     2072 16 2393                      jsr readKey ;          input = readKey();
   38:     2075 6B 81                        stab CFG_INPUT,SP ;
   39:     2077 1808 82 01                   movb #TRUE,CFG_FLAG,SP;      flag = TRUE;
   40:     207B                        cfg_if2:
   41:     207B A6 81                        ldaa CFG_INPUT,SP ;          if(input == 'a')
   42:     207D 81 61                        cmpa #'a'
   43:     207F 26 07                        bne cfg_elseif2
   44:     2081 86 00                        ldaa #0           ;               setcode(0);
   45:     2083 16 2108                      jsr setcode
   46:     2086 20 19                        bra cfg_endif2
   47:     2088                        cfg_elseif2:
   48:     2088 81 31                        cmpa #'1'         ;           else if( input>='1' && input <= '4')
   49:     208A 25 0A                        blo cfg_else2
   50:     208C 81 34                        cmpa #'4'
   51:     208E 22 06                        bhi cfg_else2
   52:     2090 80 30                        suba #ASCII_CONV_NUM  ;       {   ix = input-ASCII_CONV_NUM;
   53:     2092 07 74                        bsr setcode           ;           setcode(ix); }
   54:     2094 20 0B                        bra cfg_endif2
   55:     2096                        cfg_else2:              ;           else      
   56:     2096 CC 24AD                      ldd #CERRMSG      ;           { printf(CERRMSG);
   57:     2099 15 FB CDEB                   jsr [printf,PCr]  ;
   58:     209D 1808 82 00                   movb #FALSE,CFG_FLAG,SP ;       flag = FALSE; }
   59:     20A1                        cfg_endif2:
   60:     20A1 E7 82                        tst CFG_FLAG,SP   ;       } while(!flag);
   61:     20A3 27 C6                        beq cfg_loop
   62:     20A5                        cfg_endif1:
   63:     20A5 1B 83                        leas CFG_VARSIZE,SP
   64:     20A7 3A                           puld
   65:     20A8 3D                           rts
   66:                                 
   67:                                 ;--------------------------------
   68:                                 ; Subroutine: enterMstCode
   69:                                 ; Parameters: none
   70:                                 ; Returns: TRUE - valid code entered, FALSE otherwise - Acc A.
   71:                                 ; Description: Prompts user for the 4 digit master alarm code.
   72:                                 ;-------------------------------
   73:                                 ; Stack Usage
   74:                                         OFFSET 0 ; to setup offsets into stack
   75:     0000 +0001                  EMC_RETVAL  DS.B 1   ; retval
   76:     0001 +0001                  EMC_I       DS.B 1   ; i
   77:     0002 +0001                  EMC_INPUT   DS.B 1   ; input
   78:     0003 +0002                  EMC_ALARMCODE DS.W 1 ; alarmCode
   79:     0005 +0002                  EMC_MULT    DS.W 1   ; mult
   80:     0007                        EMC_VARSIZE:
   81:     0007 +0002                  EMC_PR_Y    DS.W 1   ; preserve Y
   82:     0009 +0002                  EMC_PR_X    DS.W 1   ; preserve X
   83:     000B +0001                  EMC_PR_B    DS.B 1   ; preserve B
   84:     000C +0002                  EMC_RA      DS.W 1   ; return address
   85:                                 
   86:     20A9 37                     enterMstCode pshb
   87:     20AA 34                        pshx
   88:     20AB 35                        pshy
   89:     20AC 1B 99                     leas -EMC_VARSIZE,SP
   90:     20AE 1808 80 00                movb #FALSE,EMC_RETVAL,SP  ; byte retval = FALSE;
   91:                                                               ; byte i;
   92:                                                               ; byte input;
   93:     20B2 1800 83 0000              movw #0,EMC_ALARMCODE,SP   ; int alarmCode = 0;
   94:     20B7 1800 85 03E8              movw #1000,EMC_MULT,SP     ; int mult = 1000;
   95:                                    
   96:     20BC CC 248C                   ldd #MSTCDMSG              ; printf(MSTCDMSG);
   97:     20BF 15 FB CDC5                jsr [printf, PCr]
   98:     20C3 69 81                     clr EMC_I,SP
   99:     20C5                        emc_for:                      ; for(i=0 ; i<4 ; i++)
  100:     20C5 16 2393                   jsr readKey                ; {
  101:     20C8 6B 82                     stab EMC_INPUT,SP          ;    input = readKey();
  102:     20CA                        emc_if1:
  103:     20CA 180F                      tba
  104:     20CC 16 2431                   jsr isdigit                ;    if(!isdigit(input))
  105:     20CF 97                        tsta
  106:     20D0 27 2E                     beq emc_endfor             ;         break;
  107:     20D2                        emc_else1:                    ;    else {
  108:     20D2 E6 82                     ldab EMC_INPUT,SP          ;       alarmCode = alarmCode + mult*(input-ASCII_CONV_NUM);
  109:     20D4 C0 30                     subb #ASCII_CONV_NUM
  110:     20D6 87                        clra
  111:     20D7 ED 85                     ldy  EMC_MULT,SP
  112:     20D9 13                        emul
  113:     20DA E3 83                     addd EMC_ALARMCODE,SP
  114:     20DC 6C 83                     std EMC_ALARMCODE,SP
  115:     20DE EC 85                     ldd EMC_MULT,SP            ;       mult = mult/10;
  116:     20E0 CE 000A                   ldx #10
  117:     20E3 1810                      idiv
  118:     20E5 6E 85                     stx EMC_MULT,SP
  119:     20E7 8E 0000                emc_if2: cpx #0               ;       if(mult == 0)  {
  120:     20EA 26 0B                     bne emc_endif2
  121:     20EC FC 245F                emc_if3: ldd alarmCodes      ;            if(alarmCode == alarmCodes[0]) 
  122:     20EF AC 83                     cpd EMC_ALARMCODE,SP
  123:     20F1 26 04                     bne emc_endif3
  124:     20F3 1808 80 01                movb #TRUE,EMC_RETVAL,SP   ;                 retval = TRUE;
  125:     20F7                        emc_endif3:
  126:     20F7                        emc_endif2:                   ;       }
  127:     20F7                        emc_endif1:                   ;    }
  128:     20F7 A6 81                     ldaa EMC_I,SP
  129:     20F9 42                        inca
  130:     20FA 6A 81                     staa EMC_I,SP
  131:     20FC 81 04                     cmpa #4
  132:     20FE 25 C5                     blo emc_for
  133:     2100                        emc_endfor:                   ; }
  134:     2100 A6 80                     ldaa EMC_RETVAL,SP         ; return(retval);
  135:     2102 1B 87                     leas EMC_VARSIZE,SP
  136:     2104 31                        puly
  137:     2105 30                        pulx
  138:     2106 33                        pulb
  139:     2107 3D                        rts
  140:                                 
  141:                                 ;---------------------------------
  142:                                 ; Subroutine; setcode (ix)
  143:                                 ; Parameters
  144:                                 ;        ix - in accumulator a
  145:                                 ; Local variables
  146:                                 ;        flag, i, input, digit, alarmCode, mult - on stack
  147:                                 ; Description: Prompts user for a 4 digit alarm code to
  148:                                 ;              update the alarm code at index ix. If 'd'
  149:                                 ;              is entered the alarm code is disabled.  It
  150:                                 ;              is not allowed to diable the master
  151:                                 ;              alarm code.void setcode(byte ix).
  152:                                 ;------------------------------------------------------
  153:                                 ; Stack Usage
  154:                                         OFFSET 0 ; to setup offsets into stack
  155:     0000 +0001                  SETC_IX   DS.B 1  ; ix
  156:     0001 +0001                  SETC_FLAG DS.B 1  ; flag
  157:     0002 +0001                  SETC_I    DS.B 1  ; i
  158:     0003 +0001                  SETC_INPUT DS.B 1 ; input 
  159:     0004 +0002                  SETC_DIGIT DS.W 1 ; digit
  160:     0006 +0002                  SETC_ALARMCODE DS.W 1  ; alarmCode
  161:     0008 +0002                  SETC_MULT DS.W 1  ; mult
  162:     000A                        SETC_VARSIZE:
  163:     000A +0002                  SETC_PR_D DS.W 1        ; preserve D
  164:     000C +0002                  SETC_PR_X DS.W 1        ; preserve D 
  165:     000E +0002                  SETC_PR_Y DS.W 1        ; preserve D  
  166:     0010 +0002                  SETC_RA DS.W 1  ; return address
  167:                                 
  168:     2108 35                     setcode: pshy       ; {
  169:     2109 34                              pshx
  170:     210A 3B                              pshd
  171:     210B 1B 96                        leas -SETC_VARSIZE,SP   ; make room for variables
  172:     210D 180B 01 0001                 movb #TRUE, SETC_FLAG   ; byte flag = TRUE;
  173:                                                               ; byte i;
  174:                                                               ; byte input;
  175:                                                               ;int digit;
  176:     2112 1800 86 0000                 movw #0,SETC_ALARMCODE,SP   ; int alarmCode=0;
  177:     2117 1800 88 03E8                 movw #1000,SETC_MULT,SP ; int mult=1000; // multiplier
  178:     211C 6A 80                        staa SETC_IX,SP         ; save parameter value
  179:     211E                        setc_loop:                    ; do {
  180:     211E CC 24B9                      ldd #GET_CODE_MSG       ;      printf(GET_CODE_MSG);
  181:     2121 15 FB CD63                   jsr [printf, PCr]
  182:     2125 69 82                        clr SETC_I,SP           ;      for(i=0 ; i< 4 ; i++)
  183:     2127                        setc_for:                     ;      {
  184:     2127 16 2393                      jsr readKey             ;         input = readKey();
  185:     212A 6B 83                        stab SETC_INPUT,SP
  186:     212C C1 64                  setc_if cmpb #'d'             ;         if(input == 'd')
  187:     212E 26 1C                        bne setc_elseif         ;         { 
  188:     2130 A6 80                  setc_if2 ldaa SETC_IX,SP      ;            if(ix == 0) 
  189:     2132 81 00                        cmpa #0
  190:     2134 26 09                        bne setc_else2
  191:     2136 CC 24C7                      ldd #ERR_MST_MSG        ;               printf(ERR_MST_MSG);
  192:     2139 15 FB CD4B                   jsr [printf,PCr]
  193:     213D 20 0B                        bra setc_endif2
  194:     213F                        setc_else2                    ;            else {
  195:     213F 1800 86 FFFF                 movw #$ffff,SETC_ALARMCODE,SP ;            alarmCode = 0xffff;
  196:     2144 1808 81 00                   movb #FALSE,SETC_FLAG,SP;                  flag = FALSE;
  197:     2148 20 3E                        bra setc_endfor          ;                 break; 
  198:     214A                        setc_endif2                   ;             }
  199:     214A 20 33                        bra setc_endif          ;         }
  200:     214C                        setc_elseif:
  201:     214C A6 83                        ldaa SETC_INPUT,SP      ;         else if(isdigit(input))
  202:     214E 16 2431                      jsr isdigit
  203:     2151 97                           tsta
  204:     2152 27 22                        beq setc_else
  205:     2154 E6 83                        ldab SETC_INPUT,SP      ;         {  digit = input - ASCII_CONV_NUM;
  206:     2156 C0 30                        subb #ASCII_CONV_NUM
  207:     2158 87                           clra
  208:     2159 6C 84                        std SETC_DIGIT,SP       ;            alarmCode = alarmCode + digit * mult;
  209:     215B ED 88                        ldy SETC_MULT,SP
  210:     215D 13                           EMUL                    ; // Result digit*mult is in D
  211:     215E E3 86                        addd SETC_ALARMCODE,SP
  212:     2160 6C 86                        std SETC_ALARMCODE,SP
  213:     2162 EC 88                        ldd SETC_MULT,SP        ;            mult = mult/10;
  214:     2164 CE 000A                      ldx #10
  215:     2167 1810                         idiv
  216:     2169 6E 88                        stx SETC_MULT,SP
  217:     216B 8E 0000                      cpx #0                  ;            if(mult == 0)
  218:     216E 26 0F                        bne setc_endif          ;             
  219:     2170 1808 81 00                   movb #FALSE,SETC_FLAG,SP ;                flag = FALSE;
  220:     2174 20 09                        bra setc_endif          ;         }
  221:     2176                        setc_else:                    ;         else {
  222:     2176 CC 24AD                      ldd #CERRMSG            ;                printf(CERRMSG);
  223:     2179 15 FB CD0B                   jsr [printf, PCr]
  224:     217D 20 09                        bra setc_endfor         ;                break;
  225:                                                               ;         }
  226:     217F                        setc_endif:
  227:     217F A6 82                        ldaa SETC_I,SP
  228:     2181 42                           inca
  229:     2182 6A 82                        staa SETC_I,SP
  230:     2184 81 04                        cmpa #4
  231:     2186 25 9F                        blo setc_for 
  232:     2188                        setc_endfor:                       ;   }
  233:     2188 E7 81                        tst SETC_FLAG,SP        ; } while(flag);
  234:     218A 26 92                        bne setc_loop
  235:     218C A6 80                        lda SETC_IX,SP   ; writeToEE( (int) &alarmCodes[ix], alarmCode);
  236:     218E 48                           lsla  ; double index value - 2 bytes/element
  237:     218F CE 245F                      ldx #alarmCodes
  238:     2192 1A E4                        leax a,x
  239:     2194 EC 86                        ldd SETC_ALARMCODE,SP
  240:     2196 07 06                        bsr writeToEE
  241:     2198 1B 8A                        leas SETC_VARSIZE,SP    ; skip over variables
  242:     219A 3A                           puld                    ; restore registers
  243:     219B 30                           pulx
  244:     219C 31                           puly
  245:     219D 3D                           rts
  246:                                 ;---------------------------------
  247:                                 ; Subroutine: writeToEE()
  248:                                 ; Parameters: address - in x register
  249:                                 ;             alarmCode    - in d register
  250:                                 ; Variables: none
  251:                                 ; Description:
  252:                                 ;     Write the alarm code in EEProm. writeEEByte() is a 
  253:                                 ;     function avaible in Debug12.
  254:                                 ;------------------------------------------------------
  255:                                 ; Stack Usage
  256:                                         OFFSET 0 ; to setup offsets into stack
  257:     0000 +0002                  WREE_PR_D DS.W 1        ; preserve D - alarmCode
  258:     0002 +0002                  WREE_PR_X DS.W 1        ; preserve X - address 
  259:     0004 +0002                  WREE_RA DS.W 1  ; return address
  260:                                 
  261:     219E 34                     writeToEE:  pshx
  262:     219F 3B                                 pshd
  263:     21A0 E6 80                              ldab WREE_PR_D,SP   ;  writeEEByte(address, (byte)((alarmCode&0xff00)>>8) );
  264:     21A2 3B                                 pshd   ; save argument on stack
  265:     21A3 B7 54                              tfr x,d ; first argument passed in D
  266:     21A5 4B FB CCFD                         call [writeEEByte, PCr]
  267:     21A9 30                                 pulx  ; remove argument
  268:     21AA EE 82                              ldx WREE_PR_X,SP     ; get address
  269:     21AC E6 81                              ldab WREE_PR_D+1,SP  ; writeEEByte(address+1, (byte)(alarmCode&0xff) );
  270:     21AE 3B                                 pshd  ; save argument on stack
  271:     21AF B7 54                              tfr x,d ; first argument passed in D
  272:     21B1 C3 0001                            addd #1 ; address+1
  273:     21B4 4B FB CCEE                         call [writeEEByte, PCr]
  274:     21B8 30                                 pulx   ; remove argument
  275:     21B9 3A                                 puld   ; restore D
  276:     21BA 30                                 pulx   ; restore X
  277:     21BB 3D                                 rts
  278:                                         
  279:                                    switch globalConst
  280:     248C 4D 61 73 74 65 72      MSTCDMSG    dc.b "Master code",NL,CR,$00
           2492 20 63 6F 64 65 0A 
           2498 0D 00 
  281:     249A 61 3A 6D 73 74 72      CONFIGMSG   dc.b "a:mstr 1-4:other",NL,CR,$00
           24A0 20 31 2D 34 3A 6F 
           24A6 74 68 65 72 0A 0D 
           24AC 00 
  282:     24AD 42 61 64 20 65 6E      CERRMSG     dc.b "Bad entry",NL,CR,$00
           24B3 74 72 79 0A 0D 00 
  283:     24B9 43 6F 64 65 20 6F      GET_CODE_MSG dc.b "Code or 'd'",NL,CR,$00
           24BF 72 20 27 64 27 0A 
           24C5 0D 00 
  284:     24C7 43 61 6E 6E 6F 74      ERR_MST_MSG dc.b "Cannot disable",NL,CR,$00
           24CD 20 64 69 73 61 62 
           24D3 6C 65 0A 0D 00 
  285:                                 
  131:                                  INCLUDE        armed.asm
    1:                                 ;------------------------------------------------------
    2:                                 ; Alarm System Assembler Program
    3:                                 ; File: armed.asm
    4:                                 ; Description: The Armed Module
    5:                                 ; Author: Gilbert Arbez
    6:                                 ; Date: Fall 2010
    7:                                 ;------------------------------------------------------
    8:                                 
    9:                                         SWITCH code_section
   10:          =00000BB8              ARMDELAY  equ 3000; 15000
   11:          =000003E8              BEEPDELAY equ 1000
   12:                                 
   13:                                 ;-------------------------------------------
   14:                                 ; Subroutine: enableAlarm
   15:                                 ; Parameters: none
   16:                                 ; Returns: nothing
   17:                                 ; Variables
   18:                                 ;       input, codeValid, delayFlag - on stack
   19:                                 ; Description:
   20:                                 ;     Gets user to enter a valid alarm code to arm
   21:                                 ;     the alarm system.  Delays 15 seconds (to allow user
   22:                                 ;     to leave; the alarm can be disarmed during this period),
   23:                                 ;     monitors for trigger events (a, b, c, d, e).  When 'a'
   24:                                 ;     is detected, 15 seconds are allowed to enter an alarm code to
   25:                                 ;     disarm the system; otherwise the alarm is triggered. For other
   26:                                 ;     trigger events, the alarm is triggered instantly.  The alarm
   27:                                 ;     system can be turned off after being triggered with an alarm
   28:                                 ;     code.
   29:                                 ;------------------------------------------------------
   30:                                 ; Stack Usage:
   31:                                         OFFSET 0  ; to setup offset into stack
   32:     0000 +0001                  EAL_INPUT      DS.B 1  ; input
   33:     0001 +0001                  EAL_CODEVALID  DS.B 1 ; codeValid
   34:     0002 +0001                  EAL_DELAYFLAG  DS.B 1 ; delayFlag
   35:     0003                        EAL_VARSIZE:
   36:     0003 +0002                  EAL_PR_D              DS.W 1 ; preserve D
   37:     0005 +0002                  EAL_RA         DS.W 1 ; return address
   38:                                 
   39:     21BC 3B                     enableAlarm:  pshd
   40:     21BD 1B 9D                     leas  -EAL_VARSIZE,SP        ;byte input;  // input from user
   41:                                                                 ;byte codeValid;  // valid alarm code found
   42:                                                                 ;byte delayFlag;
   43:                                    ;// Get a valid alarm code to arm the system
   44:     21BF CC 24D8                   ldd #CODEMSG                 ; printf(CODEMSG);
   45:     21C2 15 FB CCC2                jsr [printf, PCr]
   46:     21C6 1808 81 00                movb #FALSE,EAL_CODEVALID,SP ; codeValid = FALSE;
   47:     21CA                        eal_while1:
   48:     21CA E7 81                     tst EAL_CODEVALID,SP         ; while(!codeValid) 
   49:     21CC 26 0E                     bne eal_endwhile1            ; {
   50:     21CE 16 2393                   jsr readKey                  ;   input = readKey();
   51:     21D1 6B 80                     stab EAL_INPUT,SP
   52:     21D3 180F                      tba
   53:     21D5 16 229C                   jsr checkCode                ;     codeValid = checkCode(input);
   54:     21D8 6A 81                     staa EAL_CODEVALID,SP
   55:     21DA 20 EE                     bra eal_while1
   56:     21DC                        eal_endwhile1                   ; }
   57:                                 
   58:     21DC CC 24DF                   ldd #ARMING                   ; printf(ARMING);
   59:     21DF 15 FB CCA5                jsr [printf,PCr]
   60:                                    ; // Delay 1500 ms, i.e. 15 seconds
   61:     21E3 CC 0BB8                   ldd #ARMDELAY                 ; setDelay(ARMDELAY);
   62:     21E6 16 240B                   jsr setDelay
   63:     21E9 1808 81 00                movb #FALSE,EAL_CODEVALID,SP ; codeValid = FALSE;
   64:     21ED 1808 82 00                movb #FALSE,EAL_DELAYFLAG,SP ; delayFlag = FALSE;
   65:     21F1                        eal_while2:                     ; while(!delayFlag) 
   66:     21F1 E7 82                     tst EAL_DELAYFLAG,SP         ; {
   67:     21F3 26 27                     bne eal_endwhile2
   68:     21F5 16 240F                   jsr polldelay                ;   delayFlag = delay(); 
   69:     21F8 6A 82                     staa EAL_DELAYFLAG,SP
   70:     21FA 17 00                     jsr pollreadKey              ;   input = pollreadKey();  // check if code entered to disarm
   71:     21FC 6B 80                     stab EAL_INPUT,SP
   72:     21FE 180F                      tba
   73:     2200                        eal_if1:
   74:     2200 81 23                     cmpa #'#'                    ;   if(isdigit(input) || input == '#') 
   75:     2202 27 08                     beq eal_blk1
   76:     2204 16 2431                   jsr isdigit
   77:     2207 97                        tsta
   78:     2208 26 02                     bne eal_blk1
   79:     220A 20 0E                     bra eal_endif1   
   80:     220C                        eal_blk1:                       ;    {
   81:     220C A6 80                     ldaa EAL_INPUT,SP            
   82:     220E 16 229C                   jsr checkCode                ;        codeValid = checkCode(input);
   83:     2211 6A 81                     staa EAL_CODEVALID,SP
   84:     2213                        eal_if2:
   85:     2213 97                        tsta                         ;        if(codeValid) 
   86:     2214 27 04                     beq eal_endif2
   87:     2216 1808 82 01                movb #TRUE,EAL_DELAYFLAG,SP  ;            delayFlag = TRUE;  // break out of loop
   88:     221A                        eal_endif2:
   89:     221A                        eal_endif1:                     ;    }
   90:     221A 20 D5                     bra eal_while2               
   91:     221C                        eal_endwhile2                   ; }
   92:                                 
   93:                                    ;// Loop to monitor trigger events and alarm code to disable
   94:                                    ;// codeValid is TRUE if valid alarm code entered during delay
   95:     221C                        eal_if3:                        ; if(!codeValid)
   96:     221C E7 81                     tst EAL_CODEVALID,SP
   97:     221E 26 07                     bne eal_endif3
   98:     2220 CC 24F0                   ldd #ARMED                   ;        printf(ARMED)
   99:     2223 15 FB CC61                jsr [printf, PCr]
  100:     2227                        eal_endif3:
  101:     2227                        eal_while3                      ;  while(!codeValid)
  102:     2227 E7 81                     tst EAL_CODEVALID,SP         ; {
  103:     2229 26 6D                     bne eal_endwhile3
  104:     222B 17 00                     jsr pollReadKey              ;    input = pollReadKey();
  105:     222D 6B 80                     stab EAL_INPUT,SP
  106:     222F 180F                      tba
  107:     2231                        eal_elseif
  108:     2231 81 23                     cmpa #'#'                    ;    if(isdigit(input) || input == '#') 
  109:     2233 27 08                     beq eal_blk2
  110:     2235 16 2431                   jsr isdigit
  111:     2238 97                        tsta
  112:     2239 26 02                     bne eal_blk2
  113:     223B 20 08                     bra eal_elseifA  
  114:     223D                        eal_blk2:      
  115:     223D A6 80                     ldaa EAL_INPUT,SP             ;        codeValid = checkCode(input);
  116:     223F 07 5B                     bsr checkCode                
  117:     2241 6A 81                     staa EAL_CODEVALID,SP 
  118:     2243 20 51                     bra eal_endelseif    
  119:     2245                        eal_elseifA:
  120:     2245 16 245B                   jsr getSwStatus               ;   else if(getSwStatus() & 0b00000001) // Front door opened
  121:     2248 84 01                     anda #%00000001
  122:     224A 27 3C                     beq eal_elseifB               ;   {
  123:     224C CC 2500                   ldd #DISARMING                ;      printf(DISARMING);
  124:     224F 15 FB CC35                jsr [printf, PCr]
  125:     2253 CC 0BB8                   ldd #ARMDELAY                 ;      setDelay(ARMDELAY);
  126:     2256 16 240B                   jsr setDelay
  127:     2259                        eal_while4:                      ;      while(!codeValid)
  128:     2259 A6 81                     ldaa EAL_CODEVALID,SP         ;      {
  129:     225B 26 29                     bne eal_endwhile4 
  130:     225D                        eal_if4:
  131:     225D 16 240F                   jsr pollDelay                 ;         if(pollDelay())
  132:     2260 97                        tsta  
  133:     2261 27 09                     beq eal_else4                 ;         { 
  134:     2263 16 231D                   jsr triggerAlarm              ;            triggerAlarm();
  135:     2266 1808 81 01                movb #TRUE,EAL_CODEVALID,SP   ;            codeValid = TRUE;           
  136:     226A 20 18                     bra eal_endif4                ;         }
  137:     226C                        eal_else4                        ;         else {
  138:     226C 17 00                     jsr pollReadKey               ;            input = pollReadKey();  // check if alarm code entered to disarm
  139:     226E 6B 80                     stab EAL_INPUT,SP
  140:     2270                        eal_if5:
  141:     2270 180F                      tba                           ;            if(isdigit(input) || input == '#')
  142:     2272 81 23                     cmpa #'#' 
  143:     2274 27 08                     beq eal_blk3
  144:     2276 16 2431                   jsr isdigit
  145:     2279 97                        tsta
  146:     227A 26 02                     bne eal_blk3
  147:     227C 20 06                     bra eal_endif5   
  148:     227E                        eal_blk3:  
  149:     227E A6 80                     ldaa EAL_INPUT,SP
  150:     2280 07 1A                     bsr checkCode                ;                 codeValid = checkCode(input);
  151:     2282 6A 81                     staa EAL_CODEVALID,SP 
  152:     2284                        eal_endif5:
  153:     2284                        eal_endif4:                     ;          }
  154:     2284 20 D3                     bra eal_while4
  155:     2286                        eal_endwhile4:                  ;        }
  156:     2286                        eal_endelseifA                  ;      }
  157:     2286 20 0E                     bra eal_endelseif;      
  158:     2288                        eal_elseifB:
  159:     2288 16 245B                   jsr getSwStatus              ;      else if(getSwStatus() & 0b11111110) // other door/window opened
  160:     228B 84 FE                     anda #%11111110              ;      
  161:     228D 27 07                     beq eal_endelseifB           ;      {
  162:     228F 16 231D                   jsr triggerAlarm             ;          triggerAlarm();
  163:     2292 1808 81 01                movb #TRUE,EAL_CODEVALID,SP  ;          codeValid = TRUE;
  164:     2296                        eal_endelseifB:                 ;      }
  165:                                    ;    // ignore all other input
  166:     2296                        eal_endelseif:
  167:     2296 20 8F                      bra eal_while3
  168:     2298                        eal_endwhile3                   ; }
  169:     2298 1B 83                      leas EAL_VARSIZE,SP
  170:     229A 3A                         puld
  171:     229B 3D                         rts
  172:                                 
  173:                                 
  174:                                 ;------------------------------------------------------
  175:                                 ; Subroutine: checkCode
  176:                                 ; Parameters: input - accumulator A
  177:                                 ; Returns: TRUE when a valid alarm code is detected, FALSE otherwise - stored in 
  178:                                 ;          accumulator A
  179:                                 ; Local Variables: retval - on stack
  180:                                 ; Global Variables:
  181:                                 ;       mult - initilased to 1000 in inithw (Alarm System Module)
  182:                                 ;       alarmCode - initialised to 0 in inithw (Alarm System Module)
  183:                                 ; Descriptions: Creates alarm code using digits entered until
  184:                                 ;               4 digits are seen. After 4th digit, see if
  185:                                 ;               alarm code is valid using isCodeValid().
  186:                                 ;------------------------------------------------------
  187:                                 ; Stack usage
  188:                                         OFFSET 0
  189:     0000 +0001                  CKC_INPUT  DS.B 1 ; parameter input
  190:     0001 +0001                  CKC_RETVAL DS.B 1 ; variable retval
  191:     0002                        CKC_VARSIZE
  192:     0002 +0001                  CKC_PR_B          DS.B 1 ; preserve B
  193:     0003 +0002                  CKC_PR_X   DS.W 1 ; preserve X
  194:     0005 +0002                  CKC_PR_Y   DS.W 1 ; preserve Y
  195:     0007 +0002                  CKC_RA    DS.W 1 ; return address
  196:                                 
  197:     229C 35                     checkCode: pshy
  198:     229D 34                        pshx
  199:     229E 37                        pshb
  200:     229F 1B 9E                     leas -CKC_VARSIZE,SP       
  201:                                                               ; static int mult = 1000; // current multiplier of digit
  202:                                                               ; static int alarmCode = 0;   // alarm code value
  203:     22A1 1808 81 00                movb #FALSE,CKC_RETVAL,SP  ; byte retval = FALSE;
  204:     22A5 6A 80                     staa CKC_INPUT,SP          ; save paramater value
  205:                                    
  206:     22A7 16 2431                   jsr isdigit                ; if(isdigit(input))
  207:     22AA 97                        tsta
  208:     22AB 27 36                     beq ckc_else               ; {
  209:     22AD A6 80                     ldaa CKC_INPUT,SP          ;    alarmCode = alarmCode + (input-ASCII_CONV_NUM)*mult
  210:     22AF 80 30                     suba #ASCII_CONV_NUM
  211:     22B1 180E                      tab                        
  212:     22B3 87                        clra
  213:     22B4 FD 3000                   ldy mult
  214:     22B7 13                        emul                       ; //*mult - result in D
  215:     22B8 F3 3002                   addd alarmCode
  216:     22BB 7C 3002                   std alarmCode
  217:     22BE FC 3000                   ldd mult                   ;    mult = mult/10;
  218:     22C1 CE 000A                   ldx #10
  219:     22C4 1810                      idiv
  220:     22C6 7E 3000                   stx mult
  221:     22C9 FC 3000                   ldd mult                   ;    if(mult == 0) 
  222:     22CC 26 13                     bne ckc_endif1             ;    {
  223:     22CE FC 3002                   ldd alarmcode              ;
  224:     22D1 07 24                     bsr isCodeValid            ;       retval = isCodeValid(alarmCode);
  225:     22D3 6A 81                     staa CKC_RETVAL,SP
  226:     22D5 CC 0000                   ldd #0                     ;       alarmCode = 0;
  227:     22D8 7C 3002                   std alarmCode 
  228:     22DB CC 03E8                   ldd #1000                  ;       mult = 1000;
  229:     22DE 7C 3000                   std mult     
  230:     22E1                        ckc_endif1:                   ;     }
  231:     22E1 20 0C                     bra ckc_endif              ; }
  232:     22E3                        ckc_else:                     ; else {
  233:     22E3 CC 0000                   ldd #0                     ;       alarmCode = 0;
  234:     22E6 7C 3002                   std alarmCode 
  235:     22E9 CC 03E8                   ldd #1000                  ;       mult = 1000;
  236:     22EC 7C 3000                   std mult                   ; }
  237:     22EF                        ckc_endif:
  238:                                    
  239:     22EF A6 81                     ldaa CKC_RETVAL,SP         ; return(retval);
  240:                                    ; Restore registers and stack
  241:     22F1 1B 82                     leas CKC_VARSIZE,SP
  242:     22F3 33                        pulb
  243:     22F4 30                        pulx
  244:     22F5 31                        puly
  245:     22F6 3D                        rts      
  246:                                 
  247:                                 
  248:                                 ;------------------------------------------------------
  249:                                 ; Subroutine: isCodeValid
  250:                                 ; Parameters: alarmCode stored in register D
  251:                                 ; Local Variables
  252:                                 ;   ptr - pointer to array - in register X
  253:                                 ;   cnt, retval - on the stack.
  254:                                 ; Returns: TRUE/FALSE - Returned in accumulator A 
  255:                                 ; Description: Checks to see if alarm code is in the
  256:                                 ;              alarmCodes array.
  257:                                 ;------------------------------------------------------
  258:                                 
  259:                                 ; Stack usage
  260:                                         OFFSET 0
  261:     0000 +0002                  CDV_ALARMCODE   DS.W 1 ; alarmCode
  262:     0002 +0001                  CDV_CNT    DS.B 1 ; cnt
  263:     0003 +0001                  CDV_RETVAL DS.B 1 ; retval
  264:     0004                        CDV_VARSIZE:
  265:     0004 +0002                  CDV_PR_X   DS.W 1 ; preserve x register
  266:     0006 +0002                  CDV_RA     DS.W 1 ; return address
  267:                                 
  268:     22F7 34                     isCodeValid: pshx
  269:     22F8 1B 9C                     leas -CDV_VARSIZE,SP
  270:     22FA 6C 80                     std CDV_ALARMCODE,SP
  271:                                    ; int *ptr;  // pointer to alarmCodes
  272:     22FC 1808 82 05                movb #NUMCODES,CDV_CNT,SP ; byte cnt = 5;
  273:     2300 1808 83 00                movb #FALSE,CDV_RETVAL,SP ; byte retval = FALSE;
  274:     2304 CE 245F                   ldx #alarmCodes           ; ptr = alarmCodes;
  275:     2307                        cdv_while                    ; do
  276:     2307 EC 31                     ldd 2,X+                  ; {
  277:     2309 AC 80                     cpd CDV_ALARMCODE,SP      ;    if(*ptr++ == alarmCode)
  278:     230B 26 06                     bne cdv_endif             ;    {
  279:     230D 1808 83 01                movb #TRUE,CDV_RETVAL,SP  ;      retval = TRUE;
  280:     2311 20 04                     bra cdv_endwhile          ;      break;
  281:     2313                        cdv_endif:                   ;    }
  282:     2313 63 82                     dec CDV_CNT,SP            ;   cnt--;
  283:     2315 26 F0                     bne cdv_while             ; } while(cnt != 0); 
  284:     2317                        cdv_endwhile:
  285:     2317 A6 83                     ldaa CDV_RETVAL,SP         ;   return(retval);
  286:                                    ; restore registers and stack
  287:     2319 1B 84                     leas CDV_VARSIZE,SP 
  288:     231B 30                        pulx
  289:     231C 3D                        rts
  290:                                 
  291:                                 ;----------------------------
  292:                                 ; Subroutine: triggerAlarm
  293:                                 ; Parameters: none
  294:                                 ; Returns: nothing
  295:                                 ; Local Variables: retval, dobel, input - on stack
  296:                                 ; Description: Repeatedly sends a bel character to the
  297:                                 ;              terminal until a valid alarm code is entered.
  298:                                 ;----------------------------
  299:                                 ; Stack usage
  300:                                         OFFSET 0
  301:     0000 +0002                  TRA_DONE   DS.W 1 ; done
  302:     0002 +0001                  TRA_DONEINPUT  DS.B 1 ; doneInput
  303:     0003 +0001                  TRA_INPUT  DS.B 1 ; input
  304:     0004                        TRA_VARSIZE:
  305:     0004 +0002                  TRA_PR_D   DS.W 1 ; preserve D register
  306:     0006 +0002                  TRA_RA     DS.W 1 ; return address
  307:                                 
  308:     231D 3B                     triggerAlarm: pshd
  309:     231E 1B 9C                     leas -TRA_VARSIZE,SP
  310:     2320 1808 80 00                movb #FALSE,TRA_DONE,SP   ; byte done = FALSE;
  311:                                                              ; byte dobel;
  312:                                                              ; byte input;
  313:     2324                        tra_while:                   ; while(!done)
  314:     2324 E7 80                     tst TRA_DONE,SP         ; {
  315:     2326 26 37                     bne tra_endwhile
  316:     2328 C6 07                     ldb #BEL                  ;    putchar(BEL);
  317:     232A 87                        clra
  318:     232B 15 FB CB57                jsr [putchar, PCr]
  319:     232F CC 03E8                   ldd #BEEPDELAY            ;    setDelay(BEEPDELAY);   // 1 sec between beeps
  320:     2332 16 240B                   jsr setDelay
  321:     2335 1808 82 00                movb #FALSE,TRA_DONEINPUT,SP ; doneInput = FALSE;
  322:     2339                        tra_while2:                  ;    while(!doneInput) 
  323:     2339 E7 82                     tst TRA_DONEINPUT,SP      ;    {
  324:     233B 26 20                     bne tra_endwhile2
  325:     233D 16 240F                   jsr polldelay             ;       doneInput = delay();
  326:     2340 6A 82                     staa TRA_DONEINPUT,SP
  327:     2342 17 00                     jsr pollReadKey           ;       input = pollReadKey();  // check if code entered to disarm
  328:     2344 6B 83                     stab TRA_INPUT,SP
  329:     2346 180F                      tba
  330:     2348 81 23                     cmpa #'#'                 ;       if(isdigit(input) || input == '#') 
  331:     234A 27 08                     beq tra_blk1
  332:     234C 16 2431                   jsr isdigit
  333:     234F 97                        tsta
  334:     2350 26 02                     bne tra_blk1
  335:     2352 20 07                     bra tra_endif   
  336:     2354                        tra_blk1:
  337:     2354 A6 83                     ldaa TRA_INPUT,SP
  338:     2356 16 229C                   jsr checkCode             ;                done = checkCode(input);
  339:     2359 6A 80                     staa TRA_DONE,SP 
  340:     235B                        tra_endif: 
  341:     235B 20 DC                     bra tra_while2
  342:     235D                        tra_endwhile2                ;    }
  343:     235D 20 C5                     bra tra_while
  344:     235F                        tra_endwhile                 ; }
  345:     235F 1B 84                     leas TRA_VARSIZE,SP
  346:     2361 3A                        puld
  347:     2362 3D                        rts
  348:                                 
  349:                                 ;-------------------------------------------------------------------------
  350:                                 ; Data Structures
  351:                                 ;-------------------------------------------------------------------------
  352:                                         SWITCH globalConst
  353:                                 ; Message strings
  354:     24D8 43 6F 64 65 0A 0D      CODEMSG dc.b  "Code",NL,CR,$00
           24DE 00 
  355:     24DF 2A 2A 2A 20 41 72      ARMING  dc.b  "*** Arming ***",NL,CR,$00
           24E5 6D 69 6E 67 20 2A 
           24EB 2A 2A 0A 0D 00 
  356:     24F0 2A 2A 2A 20 41 72      ARMED   dc.b  "*** Armed ***",NL,CR,$00
           24F6 6D 65 64 20 2A 2A 
           24FC 2A 0A 0D 00 
  357:     2500 2D 2D 20 44 69 73      DISARMING dc.b  "-- Disarming --",NL,CR,$00
           2506 61 72 6D 69 6E 67 
           250C 20 2D 2D 0A 0D 00 
  358:                                 
  359:                                    switch globalVar
  360:     3000 03E8                   mult dc.w 1000
  361:     3002 0000                   alarmCode dc.w 0
  132:                                  INCLUDE keyPad.asm
    1:                                 ;----------------------------------------------------------------------
    2:                                 ; File: Keypad.asm
    3:                                 ; Author:
    4:                                 
    5:                                 ; Description:
    6:                                 ;  This contains the code for reading the
    7:                                 ;  16-key keypad attached to Port A
    8:                                 ;  See the schematic of the connection in the
    9:                                 ;  design document.
   10:                                 ;
   11:                                 ;  The following subroutines are provided by the module
   12:                                 ;
   13:                                 ; char pollReadKey(): to poll keypad for a keypress
   14:                                 ;                 Checks keypad for 2 ms for a keypress, and
   15:                                 ;                 returns NOKEY if no keypress is found, otherwise
   16:                                 ;                 the value returned will correspond to the
   17:                                 ;                 ASCII code for the key, i.e. 0-9, *, # and A-D
   18:                                 ; void initkey(): Initialises Port A for the keypad
   19:                                 ;
   20:                                 ; char readKey(): to read the key on the keypad
   21:                                 ;                 The value returned will correspond to the
   22:                                 ;                 ASCII code for the key, i.e. 0-9, *, # and A-D
   23:                                 ;---------------------------------------------------------------------
   24:                                 
   25:                                 ; Include header files
   26:                                  include "sections.inc"
    1:                                 ;--------------------------------------
    2:                                 ; File: sections.inc
    3:                                 ; Description: Defines the sections for the project.
    4:                                 ;              Note the use of the symbol SECTIONS_DEFINED
    5:                                 ;              for conditional assembly into modules.
    6:                                 ;----------------------------------------
    7:                                 
    8:                                         IFNDEF SECTIONS_DEFINED  ; Start of conditional assembly
   50:                                          ENDIF  ; End of conditional assembly
   27:                                  include "reg9s12.inc"  ; Defines EQU's for Peripheral Ports
    1:                                 *
    2:                                 *
    3:                                 *  HC12 i/o register locations (9s12dp256)
    4:                                 *
    5:                                 
    6:                                         ifndef REG9S12  ; include only if not yet included
  485:                                         endif   ; end of conditional assembly
   28:                                 
   29:                                 **************EQUATES**********
   30:                                 
   31:                                 
   32:                                 ;-----Conversion table
   33:          =00000010              NUMKEYS EQU     16      ; Number of keys on the keypad
   34:          =000000FF              BADCODE         EQU     $FF     ; returned of translation is unsuccessful
   35:          =00000000              NOKEY           EQU     $00   ; No key pressed during poll period
   36:          =00000001              POLLCOUNT       EQU     1     ; Number of loops to create 1 ms poll time
   37:                                 
   38:                                  SWITCH globalConst  ; Constant data
   39:                                  
   40:                                  ; defnitions for structure cnvTbl_struct
   41:                                  OFFSET 0
   42:     0000 +0001                  cnvTbl_code ds.b 1
   43:     0001 +0001                  cnvTbl_ascii  ds.b 1
   44:          =00000002              cnvTbl_struct_len EQU *
   45:                                 
   46:                                 ; Conversion Table
   47:     2512 EE 31                  cnvTbl  dc.b %11101110,'1'
   48:     2514 ED 32                          dc.b %11101101,'2'
   49:     2516 EB 33                          dc.b %11101011,'3'
   50:     2518 E7 61                          dc.b %11100111,'a'
   51:     251A DE 34                          dc.b %11011110,'4'
   52:     251C DD 35                          dc.b %11011101,'5'
   53:     251E DB 36                          dc.b %11011011,'6'
   54:     2520 D7 62                          dc.b %11010111,'b'
   55:     2522 BE 37                          dc.b %10111110,'7'
   56:     2524 BD 38                          dc.b %10111101,'8'
   57:     2526 BB 39                          dc.b %10111011,'9'
   58:     2528 B7 63                          dc.b %10110111,'c'
   59:     252A 7E 2A                          dc.b %01111110,'*'
   60:     252C 7D 30                          dc.b %01111101,'0'
   61:     252E 7B 23                          dc.b %01111011,'#'
   62:     2530 77 64                          dc.b %01110111,'d'
   63:                                 
   64:                                 
   65:                                 
   66:                                  SWITCH code_section  ; place in code section
   67:                                 ;-----------------------------------------------------------    
   68:                                 ; Subroutine: initKeyPad
   69:                                 ;
   70:                                 ; Description: 
   71:                                 ;       Initiliases PORT A
   72:                                 ;-----------------------------------------------------------    
   73:     2363                        initKeyPad:
   74:     2363 180B F0 0002                   movb #$F0, DDRA
   75:     2368 4C 0C 01                       bset PUCR, $01
   76:     236B 3D                             rts
   77:                                 
   78:                                 ;-----------------------------------------------------------    
   79:                                 ; Subroutine: ch <- pollReadKey
   80:                                 ; Parameters: none
   81:                                 ; Local variable:
   82:                                 ; Returns
   83:                                 ;       ch: NOKEY when no key pressed,
   84:                                 ;       otherwise, ASCII Code in accumulator B
   85:                                 
   86:                                 ; Description:
   87:                                 ;  Loops for a period of 2ms, checking to see if
   88:                                 ;  key is pressed. Calls readKey to read key if keypress 
   89:                                 ;  detected (and debounced) on Port A and get ASCII code for
   90:                                 ;  key pressed.
   91:                                 ;-----------------------------------------------------------
   92:                                 ; Stack Usage
   93:                                         OFFSET 0  ; to setup offset into stack
   94:                                 
   95:     0000                        pollReadKey: 
   96:                                 
   97:     236C 34                        pshx
   98:     236D DD 01                     ldy POLLCOUNT
   99:     236F 180B 0F 0000              movb #$0F, PORTA
  100:                                    
  101:     2374                        prk_mainloop:
  102:     2374                        prk_if1:
  103:     2374 96 00                     lda PORTA
  104:     2376 81 0F                     cmpa #$0F
  105:     2378 27 12                     beq endloops
  106:     237A CE 0BB8                   ldx #3000
  107:     237D CC 0001                   ldd #1
  108:     2380 16 2402                   jsr delayms
  109:     2383                        prk_if2:
  110:     2383 96 00                     lda PORTA
  111:     2385 81 0F                     cmpa #$0F
  112:     2387 27 03                     beq endloops
  113:     2389 16 2393                   jsr readKey
  114:                                 
  115:     238C                        endloops:
  116:     238C 03                        dey
  117:     238D 26 E5                     bne prk_mainloop
  118:     238F 30                        pulx
  119:                                 
  120:     2390 3D                        rts
  121:                                 
  122:                                 ;-----------------------------------------------------------    
  123:                                 ; Subroutine: ch <- readKey
  124:                                 ; Arguments: none
  125:                                 ; Local variable: 
  126:                                 ;       ch - ASCII Code in accumulator B
  127:                                 
  128:                                 ; Description:
  129:                                 ;  Main subroutine that reads a code from the
  130:                                 ;  keyboard using the subroutine readKeybrd.  The
  131:                                 ;  code is then translated with the subroutine
  132:                                 ;  translate to get the corresponding ASCII code.
  133:                                 ;-----------------------------------------------------------    
  134:                                 ; Stack Usage
  135:                                 ; OFFSET 0  ; to setup offset into stack
  136:     2391 +0001                  COMPARE_KEY DS.B 1
  137:     2392 +0001                  A_STORE DS.B 1
  138:                                 
  139:     2393                        readKey:
  140:     2393 36                             psha
  141:                                 
  142:     2394                        rk_loop:
  143:     2394 180B 0F 0000                   movb #$0F, PORTA        ; init port A
  144:                                 
  145:     2399 D6 00                          ldab PORTA                      ; save the current value of PORTA into B
  146:     239B C1 0F                          cmpb #$0F                       ; check if we have input
  147:     239D 27 F5                          beq rk_loop                     ; if we don't have input
  148:     239F 180C 0000 2391                 movb PORTA, COMPARE_KEY ; otherwise move input into compare_key
  149:     23A5 CC 000A                        ldd #10         ; delay for 10 ms
  150:     23A8 16 2402                        jsr delayms     ; call our function to delay
  151:     23AB 16 23B8                        jsr readKeyboard
  152:                                 
  153:                                 
  154:     23AE F1 2391                        cmpb COMPARE_KEY
  155:     23B1 26 E1                          bne rk_loop
  156:                                 
  157:     23B3 16 23E1                        jsr translate
  158:                                 
  159:     23B6 32                             pula
  160:                                 
  161:     23B7 3D                      rts                       ;  return(ch); 
  162:                                 
  163:                                 
  164:                                 ;-----------------------------------------------------------    
  165:                                 ; Subroutine: ch <- readKey
  166:                                 ; Arguments: none
  167:                                 ; Local variable: 
  168:                                 ;       ch - ASCII Code in accumulator B
  169:                                 
  170:                                 ; Description:
  171:                                 ;  Main subroutine that reads a code from the
  172:                                 ;  keyboard using the subroutine readKeybrd.  The
  173:                                 ;  code is then translated with the subroutine
  174:                                 ;  translate to get the corresponding ASCII code.
  175:                                 ;-----------------------------------------------------------
  176:                                 
  177:     23B8                        readKeyboard:
  178:     23B8 180B EF 0000                   movb #%11101111, PORTA
  179:                                 
  180:     23BD D6 00                  if1: ldab PORTA
  181:     23BF C1 EF                          cmpb #%11101111
  182:     23C1 26 1B                          bne endloop
  183:     23C3 180B DF 0000                   movb #%11011111, PORTA
  184:                                 
  185:     23C8 D6 00                  if2: ldab PORTA
  186:     23CA C1 DF                          cmpb #%11011111
  187:     23CC 26 10                          bne endloop
  188:     23CE 180B BF 0000                   movb #%10111111, PORTA
  189:                                 
  190:     23D3 D6 00                  if3: ldab PORTA
  191:     23D5 C1 BF                          cmpb #%10111111
  192:     23D7 26 05                          bne endloop
  193:     23D9 180B 7F 0000                   movb #%01111111, PORTA
  194:                                         
  195:     23DE                        endloop:
  196:     23DE D6 00                          ldab PORTA
  197:     23E0 3D                             rts
  198:                                         
  199:                                 ;-----------------------------------------------------------    
  200:                                 ; Subroutine:  ch <- translate(code)
  201:                                 ; Arguments
  202:                                 ;       code - in Acc B - code read from keypad port
  203:                                 ; Returns
  204:                                 ;       ch - saved on stack but returned in Acc B - ASCII code
  205:                                 ; Local Variables
  206:                                 ;       ptr - in register X - pointer to the table
  207:                                 ;       count - counter for loop in accumulator A
  208:                                 ; Description:
  209:                                 ;   Translates the code by using the conversion table
  210:                                 ;   searching for the code.  If not found, then BADCODE
  211:                                 ;   is returned.
  212:                                 ;-----------------------------------------------------------    
  213:                                 ; Stack Usage:
  214:                                    OFFSET 0
  215:     0000 +0001                  TR_CH DS.B 1  ; for ch 
  216:     0001 +0001                  TR_PR_A DS.B 1 ; preserved regiters A
  217:     0002 +0001                  TR_PR_X DS.B 1 ; preserved regiters X
  218:     0003 +0002                  TR_RA DS.W 1 ; return address
  219:                                 
  220:     23E1 36                     translate: psha
  221:     23E2 34                             pshx    ; preserve registers
  222:     23E3 1B 9F                          leas -1,SP                  ; byte chascii;
  223:     23E5 CE 2512                        ldx #cnvTbl                 ; ptr = cnvTbl;
  224:     23E8 87                             clra                        ; ix = 0;
  225:     23E9 1808 80 FF                     movb #BADCODE,TR_CH,SP ; ch = BADCODE;
  226:                                 
  227:     23ED                        TR_loop                             ; do {
  228:                                 
  229:                                         ; IF code = [ptr]
  230:     23ED E1 00                          cmpb cnvTbl_code,X          ;     if(code == ptr->code)
  231:     23EF 26 06                          bne TR_endif
  232:                                                                     ;     {
  233:     23F1 180A 01 80                     movb cnvTbl_ascii,X,TR_CH,SP ;        ch <- [ptr+1]
  234:     23F5 20 07                          bra TR_endwh                ;         break;
  235:     23F7                        TR_endif                            ;     }
  236:                                                                     ;     else {        
  237:     23F7 1A 02                          leax cnvTbl_struct_len,X    ;           ptr++;
  238:     23F9 42                             inca ; increment count      ;           ix++;
  239:                                                                     ;     }     
  240:     23FA 81 10                          cmpa #NUMKEYS               ;} WHILE count < NUMKEYS
  241:     23FC 25 EF                          blo TR_LOOP     
  242:     23FE                        tr_endwh ; ENDWHILE
  243:                                 
  244:     23FE 33                             pulb ; move ch to Acc B
  245:                                         ; restore registres
  246:     23FF 30                             pulx
  247:     2400 32                             pula
  248:     2401 3D                             rts
  249:                                 
  133:                                  INCLUDE        delay.asm
    1:                                 ;------------------------------------------------------
    2:                                 ; Alarm System Assembler Program
    3:                                 ; File: delay.asm
    4:                                 ; Description: The Delay Module
    5:                                 ; Author: Gilbert Arbez
    6:                                 ; Date: Fall 2010
    7:                                 ;------------------------------------------------------
    8:                                  include "sections.inc"
    1:                                 ;--------------------------------------
    2:                                 ; File: sections.inc
    3:                                 ; Description: Defines the sections for the project.
    4:                                 ;              Note the use of the symbol SECTIONS_DEFINED
    5:                                 ;              for conditional assembly into modules.
    6:                                 ;----------------------------------------
    7:                                 
    8:                                         IFNDEF SECTIONS_DEFINED  ; Start of conditional assembly
   50:                                          ENDIF  ; End of conditional assembly
    9:                                  include "alarm.inc"
    1:                                 ;---------------------------------
    2:                                 ; File: alarmSimul.inc
    3:                                 ; Description: Include file for Alarm System Simulation
    4:                                 ;              project
    5:                                 ;----------------------------------------------
    6:                                         IFNDEF ALARM_SIMUL_HDR  ; Start of conditional assembly
   21:                                          ENDIF  ; End of conditional assembly
   10:                                 
   11:                                 ; Some definitions
   12:          =00000BB8              MSCOUNT equ 3000
   13:                                 
   14:                                         SWITCH code_section
   15:                                 
   16:                                 ;-------------------------------
   17:                                 ; Subroutine delayms
   18:                                 ; Parameters: num - number of milliseconds to delay - in D
   19:                                 ; Returns: nothing
   20:                                 ; Description: Delays for num ms. 
   21:                                 ;--------------------------------
   22:     2402 3B                     delayms: pshd  
   23:     2403                        dlms_while:           ; do
   24:     2403 16 2422                   jsr delay1ms       ; delay1ms()
   25:     2406 04 34 FA                  dbne d,dlms_while  ; num--; while(num !=0)
   26:     2409                        dlms_endwhile:
   27:     2409 3A                        puld            ; restores register
   28:     240A 3D                        rts
   29:                                 
   30:                                 ;------------------------------------------------------
   31:                                 ; Subroutine setDelay
   32:                                 ; Parameters: cnt - accumulator D
   33:                                 ; Returns: nothing
   34:                                 ; Global Variables: delayCount
   35:                                 ; Description: Intialises the delayCount 
   36:                                 ;              variable.
   37:                                 ;------------------------------------------------------
   38:     240B                        setDelay: 
   39:     240B 7C 3004                   std delayCount     ; delayCount = cnt;
   40:     240E 3D                        rts
   41:                                 
   42:                                 
   43:                                 ;------------------------------------------------------
   44:                                 ; Subroutine: polldelay
   45:                                 ; Parameters:  none
   46:                                 ; Returns: TRUE when delay counter reaches 0 - in accumulator A
   47:                                 ; Local Variables
   48:                                 ;   retval - acc A cntr - X register
   49:                                 ; Global Variables:
   50:                                 ;      delayCount
   51:                                 ; Description: The subroutine delays for 1 ms, decrements delayCount.
   52:                                 ;              If delayCount is zero, return TRUE; FALSE otherwise.
   53:                                 ;------------------------------------------------------
   54:                                 ; Stack Usage:
   55:                                         OFFSET 0  ; to setup offset into stack
   56:     0000                        PDLY_VARSIZE:
   57:     0000 +0002                  PDLY_PR_X   DS.W 1 ; preserve X
   58:     0002 +0002                  PDLY_RA     DS.W 1 ; return address
   59:                                 
   60:     240F 34                     polldelay:  pshx
   61:     2410 86 00                     ldaa #FALSE     ; byte retval=FALSE; // return value
   62:     2412 16 2422                   jsr delay1ms    ; delay1ms();
   63:     2415 FE 3004                   ldx delayCount    ; delayCount--;
   64:     2418 09                        dex
   65:     2419 7E 3004                   stx delayCount
   66:     241C                        pld_if:
   67:     241C 26 02                     bne pld_endif    ; if(delayCount==0) 
   68:     241E 86 01                     ldaa #TRUE        ; retval=TRUE;
   69:     2420                        pld_endif:
   70:                                    ; restore registers and stack
   71:     2420 30                        pulx
   72:     2421 3D                        rts
   73:                                 
   74:                                 ;------------------------
   75:                                 ; Subroutine: delay1ms
   76:                                 ; Parameters:  none
   77:                                 ; Returns: nothing
   78:                                 ; Description: The subroutine delays for 1 ms and returns.      
   79:                                 ;   Core Clock is set to 24 MHz, so 1 cycle is 41 2/3 ns
   80:                                 ;   NOP takes up 1 cycle, thus 41 2/3 ns
   81:                                 ;   Need 24 cyles to create 1 microsecond delay
   82:                                 ;   8 cycles creates a 333 1/3 nano delay
   83:                                 ;       DEX - 1 cycle
   84:                                 ;       BNE - 3 cyles - when branch is taken
   85:                                 ;       Need 4 NOP
   86:                                 ;   Run Loop 3000 times to create a 1 ms delay   
   87:                                 ;---------------------------
   88:                                 ; Stack Usage:
   89:                                         OFFSET 0  ; to setup offset into stack
   90:     0000                        DLY1_VARSIZE:
   91:     0000 +0002                  DLY1_PR_X   DS.W 1 ; preserve X
   92:     0002 +0002                  DLY1_RA     DS.W 1 ; return address
   93:                                 
   94:     2422 34                     delay1ms: pshx
   95:     2423 CE 0BB8                   ldx #MSCOUNT    ; byte cntr = MSCOUNT;
   96:     2426                        dly1_while:
   97:     2426 27 07                     beq dly1_endwhile ; while(cntr != 0)
   98:                                                      ; {
   99:     2428 A7                        nop               ;   asm { nop; nop; nop; nop; }
  100:     2429 A7                        nop
  101:     242A A7                        nop
  102:     242B A7                        nop
  103:     242C 09                        dex               ;   cntr--;
  104:     242D 20 F7                     bra dly1_while    ; }
  105:     242F                        dly1_endwhile:
  106:     242F 30                        pulx
  107:     2430 3D                        rts
  108:                                 
  109:                                 ;------------------------------------------------------
  110:                                 ; Global variables
  111:                                 ;------------------------------------------------------
  112:                                    switch globalVar
  113:     3004 +0002                  delayCount ds.w 1   ; 2 byte delay counter
  134:                                  INCLUDE        utilities.asm
    1:                                 ;------------------------------------------------------
    2:                                 ; Alarm System Assembler Program
    3:                                 ; File: utilities.asm
    4:                                 ; Description: The Utilities Module
    5:                                 ; Author: Gilbert Arbez
    6:                                 ; Date: Fall 2010
    7:                                 ;------------------------------------------------------
    8:                                 
    9:                                         SWITCH code_section
   10:                                 
   11:                                 ;------------------------------------------------------
   12:                                 ; Subroutine isdigit
   13:                                 ; Parameters: chr - received in accumulator A/moved to B 
   14:                                 ; Returns: TRUE - chr is a digit, FALSE otherwise
   15:                                 ; Variables: retval in accumulator A
   16:                                 ; Description: Returns TRUE if chr is a digit character
   17:                                 ;              and FALSE otherwise.
   18:                                 ;------------------------------------------------------
   19:     2431 37                     isdigit: pshb   ; save B on stack
   20:     2432 180E                      tab          ; save Parameter in B
   21:     2434 86 00                     ldaa #FALSE  ;   byte retval = FALSE;
   22:     2436 C1 30                     cmpb #'0'    ;   if(chr >= '0' && chr <= '9') retval = TRUE;
   23:     2438 25 06                     blo ISD_endif
   24:     243A C1 39                     cmpb #'9'
   25:     243C 22 02                     bhi ISD_endif
   26:     243E 86 01                     ldaa #TRUE
   27:     2440                        ISD_endif:
   28:     2440 33                        pulb         ; restore B
   29:     2441 3D                        rts          ; return(retval); // in A
   30:                                 
   31:                                 
   32:                                 
   33:                                 ;------------------------------------------------------
   34:                                 ; Subroutine: pollgetchar
   35:                                 ; Parameters:  none
   36:                                 ; Returns: char read from SC0 or NOCHAR if none available
   37:                                 ;          Returned in Acc A
   38:                                 ; Variables:
   39:                                 ;      ptr in X register
   40:                                 ;      sum in Accumulator B       
   41:                                 ; Description: Checks the RDRF bit to see if a character
   42:                                 ;              is available before reading a character using getchar.
   43:                                 ;------------------------------------------------------
   44:                                 
   45:     2442 36                     polgetchar: psha     ; gechar destroys contents of acc A
   46:     2443 C6 FF                    ldab #NOCHAR        ;  char chr = NOCHAR;
   47:                                   
   48:     2445 4F CC 20 04              brclr sc0sr1,%00100000,PGC_endif ; if(SCI0SR1_RDRF==1) 
   49:     2449 15 FB CA37               jsr [getchar, PCr]  ;                    chr = getchar();
   50:     244D                        PGC_endif
   51:     244D 32                        pula            ; restore registers
   52:     244E 3D                        rts             ; return(chr);  in ACC B
  135:                                  INCLUDE switches.asm
    1:                                 ;-------------------------------------------------------------
    2:                                 ; Alarm System Assembler Program
    3:                                 ; File:  switches.asm
    4:                                 ; Description: This file contains the Switches module for the
    5:                                 ;              Alarm System project.
    6:                                 ;-----------------------------------------------------------------*/
    7:                                 ; Include header files
    8:                                  include "sections.inc"
    1:                                 ;--------------------------------------
    2:                                 ; File: sections.inc
    3:                                 ; Description: Defines the sections for the project.
    4:                                 ;              Note the use of the symbol SECTIONS_DEFINED
    5:                                 ;              for conditional assembly into modules.
    6:                                 ;----------------------------------------
    7:                                 
    8:                                         IFNDEF SECTIONS_DEFINED  ; Start of conditional assembly
   50:                                          ENDIF  ; End of conditional assembly
    9:                                  include "reg9s12.inc"  ; Defines EQU's for Peripheral Ports
    1:                                 *
    2:                                 *
    3:                                 *  HC12 i/o register locations (9s12dp256)
    4:                                 *
    5:                                 
    6:                                         ifndef REG9S12  ; include only if not yet included
  485:                                         endif   ; end of conditional assembly
   10:                                 
   11:                                  SWITCH code_section  ; place in code section
   12:                                 ;----------------------------------------
   13:                                 ; Subroutine: initSwitches
   14:                                 ; Parameters: none
   15:                                 ; Returns: nothing
   16:                                 ; Description: Initialises the port for monitoring the switches
   17:                                 ;              and controlling LEDs.
   18:                                 ;----------------------------------------
   19:     244F                        initSwitches:        
   20:     244F 79 0262                   clr  DDRH         ; DDRH = 0; // set to input (switches)
   21:     2452 180B FF 0264              movb #$ff,PERH     ; PERH = 0xff; // Enable pull-up/pull-down 
   22:     2457 79 0265                   clr  PPSH     ; PPSH = 0x00; // pull-up device connected to H
   23:                                                      ;             // switches ground the pins when closed.
   24:     245A 3D                        rts
   25:                                 
   26:                                 ;------------------------
   27:                                 ; Subrooutine: getSwStatus
   28:                                 ; Parameters:  none
   29:                                 ; Returns: Acc A - An 8 bit code that indicates which
   30:                                 ;          switches are opened (bit set to 1).
   31:                                 ; Description: Checks status of switches and 
   32:                                 ;              returns bytes that shows their
   33:                                 ;              status.      
   34:                                 ;---------------------------
   35:     245B                        getSwStatus:
   36:     245B B6 0260                    ldaa PTH   ;return(PTH);
   37:     245E 3D                         rts
  136:                                 
  137:                                    switch code_section
  138:     245F                        ENDCODE ;  used to define where the dataEEPROM section starts
  139:                                         end                ; end of program

Symbols:
alarmcode                       *00003002
alarmcodes                      *0000245f
armdelay                        *00000bb8
armed                           *000024f0
arming                          *000024df
ascii_conv_num                  *00000030
badcode                         *000000ff
beepdelay                       *000003e8
bel                             *00000007
cdv_alarmcode                   *00000000
cdv_cnt                         *00000002
cdv_endif                       *00002313
cdv_endwhile                    *00002317
cdv_retval                      *00000003
cdv_varsize                     *00000004
cdv_while                       *00002307
cerrmsg                         *000024ad
cfg_else2                       *00002096
cfg_elseif2                     *00002088
cfg_endif1                      *000020a5
cfg_endif2                      *000020a1
cfg_flag                        *00000002
cfg_input                       *00000001
cfg_loop                        *0000206b
cfg_varsize                     *00000003
checkcode                       *0000229c
ckc_else                        *000022e3
ckc_endif                       *000022ef
ckc_endif1                      *000022e1
ckc_input                       *00000000
ckc_retval                      *00000001
ckc_varsize                     *00000002
clksel                          *00000039
cnvtbl                          *00002512
cnvtbl_ascii                    *00000001
cnvtbl_code                     *00000000
cnvtbl_struct_len               *00000002
codemsg                         *000024d8
compare_key                     *00002391
configcodes                     *00002062
configmsg                       *0000249a
cr                              *0000000d
crgflg                          *00000037
ddra                            *00000002
ddrh                            *00000262
delay1ms                        *00002422
delaycount                      *00003004
delayms                         *00002402
disarming                       *00002500
dlms_while                      *00002403
dly1_endwhile                   *0000242f
dly1_while                      *00002426
eal_blk1                        *0000220c
eal_blk2                        *0000223d
eal_blk3                        *0000227e
eal_codevalid                   *00000001
eal_delayflag                   *00000002
eal_else4                       *0000226c
eal_elseifa                     *00002245
eal_elseifb                     *00002288
eal_endelseif                   *00002296
eal_endelseifb                  *00002296
eal_endif1                      *0000221a
eal_endif2                      *0000221a
eal_endif3                      *00002227
eal_endif4                      *00002284
eal_endif5                      *00002284
eal_endwhile1                   *000021dc
eal_endwhile2                   *0000221c
eal_endwhile3                   *00002298
eal_endwhile4                   *00002286
eal_input                       *00000000
eal_varsize                     *00000003
eal_while1                      *000021ca
eal_while2                      *000021f1
eal_while3                      *00002227
eal_while4                      *00002259
emc_alarmcode                   *00000003
emc_endfor                      *00002100
emc_endif2                      *000020f7
emc_endif3                      *000020f7
emc_for                         *000020c5
emc_i                           *00000001
emc_input                       *00000002
emc_mult                        *00000005
emc_retval                      *00000000
emc_varsize                     *00000007
enablealarm                     *000021bc
endcode                         *0000245f
endloop                         *000023de
endloops                        *0000238c
entermstcode                    *000020a9
err_mst_msg                     *000024c7
false                           *00000000
get_code_msg                    *000024b9
getchar                         *0000ee84
getswstatus                     *0000245b
inithw                          *0000202c
initkeypad                      *00002363
initswitches                    *0000244f
iscodevalid                     *000022f7
isd_endif                       *00002440
isdigit                         *00002431
mainloop                        *0000200b
menu                            *00002469
mnelse                          *00002029
mnelseif                        *00002020
mnendif                         *00002029
mscount                         *00000bb8
mstcdmsg                        *0000248c
mult                            *00003000
nl                              *0000000a
nochar                          *000000ff
numcodes                        *00000005
numkeys                         *00000010
perh                            *00000264
pgc_endif                       *0000244d
pld_endif                       *00002420
pllctl                          *0000003a
pollcount                       *00000001
polldelay                       *0000240f
pollreadkey                     *00000000
porta                           *00000000
ppsh                            *00000265
printf                          *0000ee88
prk_mainloop                    *00002374
program                         *00002000
pth                             *00000260
pucr                            *0000000c
putchar                         *0000ee86
readkey                         *00002393
readkeyboard                    *000023b8
refdv                           *00000035
regblk                          *00000000
rk_loop                         *00002394
sc0bdh                          *000000c8
sc0cr2                          *000000cb
sc0sr1                          *000000cc
setc_alarmcode                  *00000006
setc_digit                      *00000004
setc_else                       *00002176
setc_else2                      *0000213f
setc_elseif                     *0000214c
setc_endfor                     *00002188
setc_endif                      *0000217f
setc_endif2                     *0000214a
setc_flag                       *00000001
setc_for                        *00002127
setc_i                          *00000002
setc_input                      *00000003
setc_ix                         *00000000
setc_loop                       *0000211e
setc_mult                       *00000008
setc_varsize                    *0000000a
setcode                         *00002108
setdelay                        *0000240b
stack                           *00002000
synr                            *00000034
tr_ch                           *00000000
tr_endif                        *000023f7
tr_endwh                        *000023fe
tr_loop                         *000023ed
tra_blk1                        *00002354
tra_done                        *00000000
tra_doneinput                   *00000002
tra_endif                       *0000235b
tra_endwhile                    *0000235f
tra_endwhile2                   *0000235d
tra_input                       *00000003
tra_varsize                     *00000004
tra_while                       *00002324
tra_while2                      *00002339
translate                       *000023e1
triggeralarm                    *0000231d
true                            *00000001
variables                       *00003000
wait_b3                         *00002043
wree_pr_d                       *00000000
wree_pr_x                       *00000002
writeeebyte                     *0000eea6
writetoee                       *0000219e

